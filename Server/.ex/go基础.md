1.内存逃逸： 变量内存不分配到栈而是堆上
            原因：虽然栈内存会更快，但是如果把一些特殊的变量也放在栈就会不安全，例如函数返回的变量指针， 使用interface{} ， 超大结构体
                    1.函数返回了对应的栈帧就被销毁了，但是函数返回的变量指针要在外部接着使用，但是那块被引用的内存会被销毁 。返回值就不会，因为返回值是值传递，会直接拷贝一份给调用者  
                        （只要“某块内存的生命周期 超过了当前函数栈帧”， 它就必须逃逸到堆。）
                    2.interface{}不确定大小，无法放到栈。


2.内存模型：


3.各个引用类型的详解和初始化函数的区别

1.new(T)：分配一个 T 的零值并返回 *T
2.make(...)：只用于 slice / map / channel 的“初始化”  初始化结构体+分配内存

3.切片：
结构：type sliceHeader struct {
    Data *T    //指向底层数组
    Len  int
    Cap  int
}


append 到底干了什么:
若 len < cap：直接把元素写进当前底层数组（会影响共享同数组的其他 slice）
若 len == cap：分配新数组 + 拷贝旧数据 + 再写入（从此不再共享）
a := []int{1,2,3,4}
b := a[:2]       // b 和 a 共享
b = append(b, 9) // 可能改 a[2]（取决于 cap）

要判断会不会改到 a：看 b 的 cap。
如果 cap(b) 还够，append 就原地写，会污染原数组

扩容：如果所需cap>2*oldLen,直接翻倍,
     如果所需cap<2*oldLen 且 <256字节, 扩容25% (小)
     如果所需cap<2*oldLen 且 >256字节, 扩容25% (大)
     
     过程：先分配一个新数组，然后搬家 ->造成内存飙升，GC抖动，
坑： 字切片可能会影响到父切片



map:  
0.结构：
hmap
├─ buckets: [ bucket0 | bucket1 | ... | bucket(2^B-1) ]
└─ oldbuckets (only during grow)

bucket
├─ top hash[8]
├─ keys[8]
├─ values[8]
└─ overflow → bucket → bucket ...

1.set一个元素的时候发生的（）：
    计算hash，分为高八位和低八位，（低八位用于找到桶的位置，高八位用于桶内快速筛选）
    1.先用低八位找到桶的位置，在该桶的topHash[]寻找高八位，找到了就修改对应的value，如果没找到就在桶内新增一个key，如果该桶已经满8个key了，则需要创建一个新的桶链接到overflow
    
2.如何扩容：渐进式扩容，先创建好新的桶，然后每次操作都带一点过去


GC 

1.三色标记： 从根变量开始，利用广度优先变量对所有有依赖路径的变量染色，最后没染到色的变量就是垃圾变量

          标记：   从根节点（黑）出发（栈变量，全局变量） ，把其直接引用的所有变量置灰

                  把所有的灰变量的引用置黑，再把其所有的引用变量置灰，重复这个步骤，直到没有灰色变量

          多核并发：GC程序和 应用程序并发所带来的问题是，应用程序会修改GC程序已经标记的变量，例如已经被扫描过的黑色变量（不会再处理），又直接引用了新的白色变量，这就导致了这个白色变量最后会被当做垃圾回收掉
                   为了解决这个问题，go提出了弱三色一致性：黑色变量直接引用白色变量时，必须保证有一个灰色变量

          如何实现：混合读写屏障，相当于在GC阶段的写操作会被包装一层，把直接引用白色变量的黑色变量置灰。
             
          GC友好的代码：



GMP:


