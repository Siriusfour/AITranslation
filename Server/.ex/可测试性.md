
测试规范：
一 、单元测试要求：
1.正常输入是否返回正常输出，2.错误输入是否有执行错误逻辑/处理机制，3.边界情况    
3.要求：表驱动测试，要测试的函数不能有依赖性
2.改动频繁的话，执行要快，外部依赖如MySQL,Redis,MQ都用mock覆盖，

二、如何使用git：
根据git flow规范  分为三个分支，master，release，develop
master就是随时可以上线的大版本，而且只能通过merger来更新，不能push
develop 是开发功能的集合

每个人负责项目一个功能，开始先从develop 复制develop 分支到feature，在该分支上编写代码，开发完成之后提交，通过CI merge到develop分支
项目大部分功能完成之后就develop 签出到release（git checkout -b） ，进行环境测试，打标签，改bug
没问题了就签出到maser分支

三、什么是优秀代码风格 ：

1.依赖关系只能是自顶向下（解耦，模块化，代码风格清晰，可读性），通过参数传递，且只注入需要的依赖，（从main函数引用全局变量、构建基础设施，然后在main里面一步一步精细化拆分，只把某个对象需要的东西给到他）

2.在初始化时使用全局单例（gloabl变量只提供相关接口，不直接暴露），在业务逻辑（controller，service，DAO）使用依赖注入

3.遵循单一职责原理，controller就只做参数解析，拼接响应，service只做业务逻辑处理，DAO只做数据库操作，工具类就只管输入输出，

4.做好代码的模块化和抽象化，多依赖抽象的接口而不是具体的实现（OAuth供应商）

5.显式依赖，依赖关系一目了然。修改代码

可测试性：
1.测试范围：
自己实现的工具类，如jwt的校验和生成，雪花算法的id生成，
有边界情况的地方，比如支付金额为负数的时候能不能正确处理这个非法参数，还有状态机的状态跳转逻辑符不符合业务（不能待支付->已完成）
和另外一些模块有高耦合性的地方，防止别的模块的改动会涉及到该模块


可观侧性：
监控：Prometheus+grafana  链路分析：zipkin  日志：业务日志+http日志+DB日志，每条日志都要带traceID
首先通过promethues报警提醒，比如磁盘IO爆了，内存爆了，cpu使用率了，比如某个关键接口超时，MQ堆积量，然后根据zipkin去看看调用函数或者微服务调用路径，
粗略地去查看到底是链路上哪一步出了问题，然后再根据更具体的工具排查，比如如果是sql慢了就根据慢sql日志优化，

日志需要记录什么：
http采样记录，traceID, url路径, 客户端id，页面来源，http状态码，自定义状态码

四、CICD
github Action
  
CI自动测试，检验代码质量：  自动拉取代码，编译，运行单元测试，格式排版（go-fmt）， 静态检查（golangClient-lint）

静态检查
CD自动部署，运行环境测试：  构筑docker镜像，根据docker-compose部署环境，运行环境测试


五、设计模式
很多设计模式都在做一件事：使得代码更加模块化，是一个由面到点的过程，模块化也意味着解耦，可插拔。比如策略模式就是把依赖实例变成依赖抽象接口，把这些具体的实现放到外面，依赖者就只管调用这个方法就好，
观察者模式就是解耦动作方和通知方，把行为代码变成一个事件驱动行为，解耦之后就可以以模块为一个最小单位去重构或者修改，只要我保证这个模块的输入输出不变，那它就不会影响到上下游，维护，修改，重构，灰度发布，都能收益

六、数据库优化
1.SQL优化，2.表结构优化，3.架构优化

1.SQL优化：  
使用EXPAIN语句分析
type 性能等级：
        const（最好）：通过主键索引查到唯一记录  select * form userinfo WHERE id = 1
        ref  （次好）: 通过普通索引查找到多行记录  select * form userinfo WHERE userName = “amy”
        index（合格）: 
key 实际使用的索引：
        判断有无走预期的索引，索引有无失效
                失效的情况：一个索引和索引键的顺序有关，一旦select语句违背了索引的顺序都会让索引失效，如Index1(A,B,C)，语句select * form table_name where B=1(联合索引不按顺序)
                          在查找条件上做运算上做运算 ；SELECT * FROM items WHERE price + 10 = 100;

Extra (额外信息)：
        警告：1.Using filesort：ORDER BY沒有利用索引排序



2.表结构优化：
三大范式   ：  1.列不可再分 2.主键（联合主键）必须完全依赖，而不是只依赖一部分  3.依赖方向唯一（B,C全都依赖于列A,而不是列C依赖列B，B再依赖与A）

查询驱动设计： 先看这条sql要做什么事情，然后设计一些冗余字段，取代一些count ，join，和锁操作，让order by，group by操作可以走索引

冷热分离   ： 把不常用的数据拆开放到另外一张表，比如订单快照，只有交易有争议的时候会用到，大多数情况都是不用的，而且又很大，占用磁盘IO和Buffet pool，不如拆开单独一张表 

3.架构设计 ：


1 3 5  

4 4
