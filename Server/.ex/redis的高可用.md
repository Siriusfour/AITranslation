主从复制：

一个master节点，一个slave节点，主从复制，可能会有数据丢失，切换需要手动

哨兵模式：

一个master节点，多个slave节点 多个sentinel节点
正常模式下master节点负责正常的读和写，并把自身的数据复制到多个slave节点备份（第一次全量，后面复制增量），每个sentinel节点都会向master节点确认心跳（轮询）
如果有超过半数的sentinel确认当前的master已经挂了，那他们就会一raft共识算法投票在多个slave节点选出一个新的master
Q1：主从切换期间大概会有10s的不可读，怎么处理？
A1：根据请求的种类区分不同的处理方式，

分布式集群：

数据结构：
string：存储单个kv对， SDS,就是在一个结构体显式维护容量cap，已用长度len，数组本体
hash：存储对象的信息，例如一个用户的所有信息，
set：唯一集合，
zset：排行榜，延时任务
list ： 
Bitmap：签到统计
GEO：

雪崩：大量key同时过期
穿透：多次访问不存在的key
击穿：某一个热点key过期，



高可用设计： 主从复制，哨兵模式，高可用集群
 
1.主从切换期间会有10秒的不可用，如何解决：
A：请求线程会在3秒内再次请求，redis操作再次失败才阻塞，然后写入MQ，等待redis复苏后重新写入，而不是直接阻塞，相当于线程获取不到锁时的自旋等待一小段时间

2.如果 Redis 主从切换时间过长，大量请求都阻塞在这里，你怎么防止服务线程被拖死？
A:根据不同的请求有不同的处理方式，一般不重要的api直接快速失败返回错误， 读取请求就有很多处理方案，比如做令牌桶限流让部分流量直接访问数据库，或者放回旧数据（快照，默认值），写请求可以先存储到MQ，等待redis复苏后重新写入

3.redis实现分布式锁：
系统内不同主机的所有线程都能看见的锁，用于串行处理公共资源
实现：加锁SET key：id NX outTime， 解锁Lua脚本 ，不管是用什么实现，都是基于共享内存的计数器，生产者-消费者问题
如何处理锁过期业务还在进行的问题：看门狗，启动一个协程自动续锁