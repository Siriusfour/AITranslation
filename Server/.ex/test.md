
测试规范：
一 、单元测试要求：
1.正常输入是否返回正常输出，2.错误输入是否有执行错误逻辑/处理机制，3.边界情况 ）要求：表驱动测试，要测试的函数不能有依赖性
2.改动频繁的话，执行要快，外部依赖如MySQL,Redis,MQ都用mock覆盖，

二、如何使用git：
根据git flow规范  分为三个分支，master，release，develop
master就是随时可以上线的大版本，而且只能通过merger来更新，不能push
develop 是开发功能的集合

每个人负责项目一个功能，开始先从develop 复制develop 分支到feature，在该分支上编写代码，开发完成之后提交，通过CI merge到develop分支
项目大部分功能完成之后就develop 签出到release（git checkout -b） ，进行环境测试，打标签，改bug
没问题了就签出到maser分支

三、什么是优秀代码风格 ：
可测试性。测试范围：自己实现的工具类，如jwt的校验和生成，雪花算法的id生成，一些改动频繁，有边界情况的地方，比如支付金额为负数的时候能不能正确处理这个非法参数，还有状态机的状态跳转逻辑符不符合业务（不能待支付->已完成），

1.依赖关系只能是自顶向下，通过参数传递，且只注入需要的依赖，（从main函数引用全局变量、构建基础设施，然后在main里面一步一步精细化拆分，只把某个对象需要的东西给到他）

2.在初始化时使用全局单例（gloabl变量只提供相关接口，不直接暴露），在业务逻辑（controller，service，DAO）使用依赖注入

3.遵循单一职责原理，controller就只做参数解析，拼接响应，service只做业务逻辑处理，DAO只做数据库操作，工具类就只管输入输出，

4.做好代码的模块化和抽象化，多依赖抽象的接口而不是具体的实现（OAuth供应商）

5.显式依赖，依赖关系一目了然。修改代码


可观侧性：
监控：Prometheus+grafana  链路分析：zipkin  日志：业务日志+http日志+DB日志，每条日志都要带traceID
首先通过promethues报警提醒，比如磁盘IO爆了，内存爆了，cpu使用率了，比如某个关键接口超时，MQ堆积量，然后根据zipkin去看看调用函数或者微服务调用路径，
粗略地去查看到底是链路上哪一步出了问题，然后再根据更具体的工具排查，比如如果是sql慢了就根据慢sql日志优化，

日志需要记录什么：
http采样记录，traceID, url路径, 客户端id，页面来源，http状态码，自定义状态码

四、CICD
github Action

CI自动测试，检验代码质量：  自动拉取代码，编译，运行单元测试，格式排版（go-fmt）， 静态检查（golangClient-lint）

静态检查
CD自动部署，运行环境测试：  构筑docker镜像，根据docker-compose部署环境，运行环境测试


五、设计模式
很多设计模式都在做一件事：使得代码更加模块化，是一个由面到点的过程，模块化也意味着解耦，可插拔。比如策略模式就是把依赖实例变成依赖抽象接口，把这些具体的实现放到外面，依赖者就只管调用这个方法就好，
观察者模式就是解耦动作方和通知方，解耦之后就可以以模块为一个最小单位去重构或者修改，只要我保证这个模块的输入输出不变，那它就不会影响到上下游，维护，修改，重构，灰度发布，都能收益
