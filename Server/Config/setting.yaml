Mode:
  Develop : true
  Product : false  #production
  DoMain : "suis.com"

HttpServer:
  Port: ":3008"
  TrustProxies: #设置gin可以信任的代理服务器(例如 nginx 前置代理服务器),详情参见文档：https://www.yuque.com/xiaofensinixidaouxiang/bkfhct/vmobe7
    IsOpen: 0                       # 可选值（0 或者 1）,如果 go 服务是被 nginx 代理，建议该值设置为 1，将 nginx 代理及机器的ip添加到 ProxyServerList 列表
    # nginx 代理服务器ip地址
    ProxyServerList:
      - "192.168.10.1"
      - "192.168.10.2"



Logs:

  MQ: "/Storage/Logs/MQ.log"
  Db: "/Storage/Logs/DB.log"
  Business: "/Storage/Logs/Business.log"
  TextFormat: "json"                                  #记录日志的格式，参数选项：console、json ， console 表示一般的文本格式
  TimePrecision: "millisecond"                         #记录日志时，相关的时间精度，该参数选项：second  、 millisecond ， 分别表示 秒 和 毫秒 ,默认为毫秒级别
  MaxSize: 10                                           #每个日志的最大尺寸(以MB为单位）， 超过该值，系统将会自动进行切割
  MaxBackups: 7                                        #保留旧日志最大个数
  MaxAge: 15                                           #保留旧日志最大天数
  Compress: false                                      #日志备份时，是否进行压缩


WebAuthn :
  rp :
    name: "Suis笔记小说共享网"
    ID : "http://localhost:5173"
  Attestation : "none"  #认证器证明类型
  CryptoType : -7          #服务器支持的加密类型
  AuthenticatorAttachment: "platform "  #用户端向认证器验证身份的类型
  TimeOut : 30000
  fmt : "none"
  Challenge_TTL : 1  #1分钟
  RPID : "localhost"

Redis:
  DNS: "localhost:6379"
  DB: 0
  Password: ""


grpc:
  DNS: "127.0.0.1:5001"        #192.168.3.205

Token:
  AkOutTime: 3     #3小时
  RkOutTime: 72   #3天


SnowFlake:
  SnowFlakeMachineId: 2
  RollbackThresholdMs: 5


DB:
  SlowThreshold: 5            # 慢 SQL 阈值(sql执行时间超过此时间单位（秒），就会触发系统日志记录)
  Mode : 0
  MySQL:
    IsInitGlobalGormMysql: 1
    IsOpenReadDB: 0 # 随项目启动为gorm db初始化一个全局 variable.GormDbMysql（完全等于*gorm.Db）,正确配置数据库，该值必须设置为: 1
    Write:
      Host: "127.0.0.1"
      DataBase: "Note_Writer"
      Port: 3306
      User: "root"
      Password: "123456789"    #更好的方案：在环境变量中获取
      Charset: "utf8"
      MaxIdleConns: 10
      MaxOpenConns: 128
      ConnMaxLifetime: 60    # 连接不活动时的最大生存时间(秒)
                         # 是否开启读写分离配置（1=开启、0=关闭），IsOpenReadDb=1,Read 部分参数有效，否则Read部分参数直接忽略

    Read:
      Host: "127.0.0.1"
      DataBase: "Note_Reader"
      Port: 3308                        #注意，非3306，请自行调整
      Prefix: "tb_"
      User: "root"
      Password: "123456789"
      Charset: "utf8"
      SetMaxIdleConns: 10
      SetMaxOpenConns: 128
      SetConnMaxLifetime: 60


  #################=====PostgreSQL====#####################################
  # 如果要使用postgresql数据库，请在 app/model 目录，将 users_for_postgres.txt 的内容直接覆盖同目录的 users.go 即可
  PostgreSql:
    IsInitGlobalGormPostgreSql: 0  # 随项目启动为gorm db初始化一个全局 variable.GormDbMysql（完全等于*gorm.Db）,正确配置数据库，该值必须设置为: 1
    Write:
      Host: "127.0.0.1"
      DataBase: "DB_Note"
      Port: 5432
      Prefix: "tb_"
      User: "postgres"
      Pass: "Secret2017~"
      SetMaxIdleConns: 10
      SetMaxOpenConns: 128
      SetConnMaxLifetime: 60

    IsOpenReadDb: 0            # 是否开启读写分离配置（1=开启、0=关闭），IsOpenReadDb=1,Read  部分参数有效，否则Read部分参数直接忽略

    Read:
      Host: "127.0.0.1"
      DataBase: "DB_Note"
      Port: 5432
      Prefix: "tb_"
      User: "postgres"
      Pass: "secret2017"
      SetMaxIdleConns: 10
      SetMaxOpenConns: 128
      SetConnMaxLifetime: 60

RabbitMq:
  HelloWorld:
    #消息服务器地址、账号、密码， / (斜杠)表示默认的虚拟主机，如果是开发者自己创建的，直接追加在 / (斜杠)后面即可，例如：amqp://账号:密码@ip地址:5672/ginskeleton
    Addr: "amqp://账号:密码@ip地址:5672/"
    QueueName: "helloword_queue"
    Durable: false                                        #消息是否持久化
    ConsumerChanNumber: 2                                 #消费者通道数量（允许一个消费者使用几个连接通道消费、处理消息）
    OffLineReconnectIntervalSec: 5                        #消费者掉线后,重连间隔的秒数
    RetryCount: 5                                         #消费者掉线后,尝试重连最大次数
  WorkQueue:
    Addr: "amqp://账号:密码@ip地址:5672/"  #参照前文地址说明
    QueueName: "work_queue"
    Durable: false                                        #消息是否持久化
    ConsumerChanNumber: 2                                 #消费者通道数量（允许一个消费者使用几个连接通道消费、处理消息）
    OffLineReconnectIntervalSec: 5                        #消费者掉线后,重连间隔的秒数
    RetryCount: 5                                         #消费者掉线后,尝试重连最大次数
  PublishSubscribe:
    Addr: "amqp://账号:密码@ip地址:5672/"   #消息服务器地址、账号、密码
    ExchangeType: "fanout"
    ExchangeName: "fanout_exchange"                       #即时消息队列名称，
    DelayedExchangeName: "delayed_fanout_exchange"        #延迟消息队列名称，必须事先在rabbitmq 服务器管理端手动创建
    Durable: false                                        #消息是否持久化，如果初始化的是延迟消息队列,那么该参数会被程序强制设置为 true
    QueueName: ""                                         #队列名称，为空 表示所有订阅的消费者（consumer）都可以接受到同样的消息，如果设置名称，会导致只有最后一个启动的消费者能接受到消息。
    ConsumerChanNumber: 1                                 #消费者通道数量（发布、订阅模式消费者使用一个通道，避免多个通道重复收到数据）
    OffLineReconnectIntervalSec: 10                       #消费者掉线后,重连间隔的秒数
    RetryCount: 5                                         #消费者掉线后,尝试重连最大次数
  Routing:
    Addr: "amqp://账号:密码@ip地址:5672/"   #参照前文地址说明
    ExchangeType: "direct"
    ExchangeName: "direct_exchange"
    DelayedExchangeName: "delayed_direct_exchange"        #延迟消息队列名称，必须事先在rabbitmq 服务器管理端手动创建
    Durable: false                                        #消息是否持久化，如果初始化的是延迟消息队列,那么该参数会被程序强制设置为 true
    QueueName: ""
    OffLineReconnectIntervalSec: 10                       #消费者掉线后,重连间隔的秒数
    RetryCount: 5                                         #消费者掉线后,尝试重连最大次数
  Topics:
    Addr: "amqp://账号:密码@ip地址:5672/"   #参照前文地址说明
    ExchangeType: "topic"
    ExchangeName: "topic_exchange"
    DelayedExchangeName: "delayed_topic_exchange"         #延迟消息队列名称，必须事先在rabbitmq 服务器管理端手动创建
    Durable: false                                        #消息是否持久化，如果初始化的是延迟消息队列,那么该参数会被程序强制设置为 true
    QueueName: ""
    OffLineReconnectIntervalSec: 10                       #消费者掉线后,重连间隔的秒数
    RetryCount: 5